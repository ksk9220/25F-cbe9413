# -*- coding: utf-8 -*-
"""HW1 Intro to Sust Energy Sys.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T1dzMUbAf2VEhCIyPlGVrRGDnDAsctfB
"""

pip install pvlib -q

import pandas as pd
import pvlib
from pvlib.location import Location
from pvlib.pvsystem import PVSystem, Array, FixedMount, SingleAxisTrackerMount
from pvlib.modelchain import ModelChain
from pvlib.iotools import get_psm3
import os # Import the os module

# Define global variables
year = 2022
api_key = 'hIHY2oEGnFoLog9k5C2dByWD7hOO5h9IYw5sLbQ0'
email = 'ksk9220@nyu.edu'

def download_nsrdb_data(lat, lon, tz):

    # 2. Download NSRDB data for the particular location
    data, meta = get_psm3(latitude=lat, longitude=lon, names=str(year), api_key=api_key, email=email, map_variables=True)

    # 3. Localize to site's timezone
    data.index = data.index.tz_convert(tz)
    location = Location(latitude=lat, longitude=lon, tz=tz, altitude=meta['altitude'])

    #4. Convert solar irradiance data to CSV file
    if not os.path.exists('outputs'):
        os.makedirs('outputs')

    # Construct filename using lat, lon, and year
    filename = f'outputs/nsrdb_data_{lat}_{lon}.csv'
    data.to_csv(filename)

    return data, location

download_nsrdb_data(42.3, -71.1, 'America/New_York')
download_nsrdb_data(33.4, -112.1, 'America/Phoenix')

# System specific parameters
def pvsizing(lat, lon, tz, PlantCapacityDC, surface_tilt, azimuth_angle, dc_ac_ratio, save_output_df=True):

  data, meta = get_psm3(latitude=lat, longitude=lon, names=str(year), api_key=api_key, email=email, map_variables=True)
  data.index = data.index.tz_convert(tz)
  location = Location(latitude=lat, longitude=lon, tz=tz, altitude=meta['altitude'])

  PlantCapacityDC = 100 # System capacity (MW) of PV system
  surface_tilt = surface_tilt  # Surface tilt angle (degrees)
  azimuth_angle = azimuth_angle  # Azimuth angle (degrees)
  module_power = 400  # Power rating of the module (W)
  modules_per_string = 1000  # Number of modules in series per string
  strings_per_inverter = 10  # Number of strings for each inverter
  dc_ac_ratio = dc_ac_ratio  # DC to AC ratio
  inverter_nom_loss = 0.04  # Inverter nominal loss (4%)
  module_params = {'pdc0': module_power, 'gamma_pdc': -0.004}
  SystemCapacityDC = module_power * modules_per_string * strings_per_inverter # DC capacity handled by each inverter (W)
  inverter_params = {
          'pdc0': SystemCapacityDC/dc_ac_ratio, # PVWatts for max AC capacity
          'eta_inv_nom': 1 - inverter_nom_loss
      }

  # system losses parameters (percent units)
  # Source:  A. P. Dobos, "PVWatts Version 5 Manual"  http://pvwatts.nrel.gov/downloads/pvwattsv5.pdf
  losses = {
          'soiling': 2,
          'shading': 3,
          'snow': 0,
          'mismatch': 2,
          'wiring': 2,
          'connection': 0.5,
          'lid': 1,
          'nameplate_rating': 0.0,
          'age': 0.0,
          'availability': 3
      }


  #5.  Define PV system
  # Specifying type of mounting - fixed tilt or single axis tracking
  # NOTE: COMMENT ONE OF THE MOUNT DEFINITION FUNCTIONS
  ## Fixed tilt system definition:
  mount = FixedMount(surface_tilt=surface_tilt,
                      surface_azimuth=azimuth_angle)
  ## Single axis tracking system definition:
  # mount = SingleAxisTrackerMount(
  #         axis_tilt=surface_tilt,
  #         axis_azimuth=azimuth_angle,   # Assuming south-facing axis
  #         backtrack=True,     # Enable backtracking for the tracker
  #         gcr=0.33,  # Ground coverage ratio
  #         max_angle=60.0,      # Maximum angle for backtracking
  # )

  # Define the PV array function using the specified mount
  array = Array(
      mount=mount,
      module='pvwatts_dc',
      module_parameters=module_params,
      modules_per_string=modules_per_string,
      strings= strings_per_inverter, # Number of strings in parallel part of the system
      temperature_model_parameters=pvlib.temperature.TEMPERATURE_MODEL_PARAMETERS['sapm']['open_rack_glass_glass']
  )

  # Define the PV system, including inverter
  # The PVSystem represents one inverter and the PV modules that supply DC power to the inverter.
  system = PVSystem(arrays=[array],
                    inverter_parameters=inverter_params,
                    module='pvwatts_ac',
                    modules_per_string=modules_per_string,
                    strings_per_inverter=strings_per_inverter,
                  losses_parameters=losses,
                    albedo='urban')
  mc = ModelChain(system, location,
                  aoi_model='physical',
                  spectral_model='no_loss',
                  dc_model='pvwatts',
                  ac_model='pvwatts',
                  temperature_model='sapm',
                  transposition_model='perez',
                  losses_model='pvwatts')

  # 6. Run the model to simulate system performance
  mc.run_model(weather=data)


  NumberofSystems = PlantCapacityDC / (SystemCapacityDC/1e+6)  # Number of systems in parallel needed to meet the plant capacity
  ac_output = mc.results.ac/1e+6 * NumberofSystems  # Hourly AC power output (MW)
  dc_output = mc.results.dc/1e+6 * NumberofSystems  # Hourly DC power output (MW)
  ac_cuf = ac_output/(PlantCapacityDC) # Hourly AC CUF

  # Annual capacity factor calculation
  annual_ac_CF = ac_output.sum()/(PlantCapacityDC/dc_ac_ratio*8760)
  annual_dc_CF = dc_output.sum()/(PlantCapacityDC*8760)

  output_df = pd.DataFrame({
      'time': data.index,
      'ac_cuf': ac_cuf})

  if save_output_df:
    if not os.path.exists('outputs'):
          os.makedirs('outputs')

    filename = f'outputs/hourly_cuf_{lat}_{lon}.csv'
    output_df.to_csv(filename)

  print("Annual AC Output in MWh:", ac_output.sum())
  print("Annual AC Capacity Factor:", annual_ac_CF*100, "%")

  return output_df, annual_ac_CF

pvsizing(42.1,-71.1,'America/New_York',100, 42.1,180,1.2)

pvsizing(33.4,-112.1,'America/Phoenix',100, 33.4,180,1.2)

import matplotlib.pyplot as plt
import numpy as np

# Define the range of surface tilts
tilt_angles = np.arange(0, 60, 10)
dc_ac_ratios = np.arange(1,1.6,0.1)
azimuth_angles = np.arange(-30+180, 30+180, 20)

# Lists to store results
annual_ac_cfs = []

# Run pvsizing for each tilt angle
for tilt in tilt_angles:
    # Call pvsizing with the current tilt angle, keeping other parameters constant
    # Use the parameters from the previous pvsizing call in cell 68mek36S0fTj
    # Set save_output_df=False to suppress saving the DataFrame
    _, annual_ac_cf = pvsizing(42.1, -71.1, 'America/New_York', 100, tilt, 180, 1.2, save_output_df=False)
    annual_ac_cfs.append(annual_ac_cf)

# Plot the results as vertical bars
plt.figure(figsize=(6, 4)) # Increased figure size for better bar chart visualization
plt.bar(tilt_angles, [cf * 100 for cf in annual_ac_cfs]) # Plotting capacity factor as percentage
plt.xlabel('Surface Tilt Angle (degrees)')
plt.ylabel('Annual AC Capacity Factor (%)')
plt.title('Annual AC Capacity Factor vs. Surface Tilt Angle')
plt.grid(axis='y') # Add horizontal grid lines for easier reading
plt.xticks(np.arange(0, 51, 10))
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Define the range of DC/AC ratios
dc_ac_ratios = np.arange(1.0, 1.6, 0.1)

# Lists to store results
annual_ac_cfs_dcac = []

# Run pvsizing for each DC/AC ratio
for ratio in dc_ac_ratios:
    # Call pvsizing with the current DC/AC ratio, keeping other parameters constant
    # Use the parameters from the previous pvsizing call, keeping tilt and azimuth fixed
    _, annual_ac_cf = pvsizing(42.1, -71.1, 'America/New_York', 100, 42.1, 180, ratio, save_output_df=False)
    annual_ac_cfs_dcac.append(annual_ac_cf)

# Plot the results as vertical bars
plt.figure(figsize=(6, 4)) # Increased figure size for better bar chart visualization
plt.bar(dc_ac_ratios, [cf * 100 for cf in annual_ac_cfs_dcac], width=0.04) # Plotting capacity factor as percentage, adjusted width
plt.xlabel('DC/AC Ratio')
plt.ylabel('Annual AC Capacity Factor (%)')
plt.title('Annual AC Capacity Factor vs. DC/AC Ratio')
plt.grid(axis='y') # Add horizontal grid lines for easier reading
plt.xticks(np.arange(1.0, 1.6, 0.1)) # Set x-axis ticks at intervals of 0.1
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Define the range of azimuth angles
azimuth_angles = np.arange(150, 211, 15)

# Lists to store results
annual_ac_cfs_azimuth = []

# Run pvsizing for each azimuth angle
for azimuth in azimuth_angles:
    # Call pvsizing with the current azimuth angle, keeping other parameters constant
    # Use the parameters from the previous pvsizing call, keeping tilt and DC/AC ratio fixed
    _, annual_ac_cf = pvsizing(42.1, -71.1, 'America/New_York', 100, 42.1, azimuth, 1.2, save_output_df=False)
    annual_ac_cfs_azimuth.append(annual_ac_cf)

# Plot the results as vertical bars
plt.figure(figsize=(6, 4)) # Increased figure size for better bar chart visualization
plt.bar(azimuth_angles, [cf * 100 for cf in annual_ac_cfs_azimuth], width=4) # Plotting capacity factor as percentage, adjusted width
plt.xlabel('Azimuth Angle (degrees)')
plt.ylabel('Annual AC Capacity Factor (%)')
plt.title('Annual AC Capacity Factor vs. Azimuth Angle')
plt.grid(axis='y') # Add horizontal grid lines for easier reading
plt.xticks(np.arange(150, 211, 10)) # Set x-axis ticks at intervals of 10
plt.show()

from scipy.optimize import minimize
import pandas as pd

# Define the objective function to minimize (negative of the annual AC Capacity Factor)
def objective(params, lat, lon, tz, PlantCapacityDC):
    surface_tilt, azimuth_angle, dc_ac_ratio = params

    _, annual_ac_CF = pvsizing(lat, lon, tz, PlantCapacityDC, surface_tilt, azimuth_angle, dc_ac_ratio)

    return -annual_ac_CF

# Define the parameters for the optimization
lat = 42.1
lon = -71.1
tz = 'America/New_York'
PlantCapacityDC = 100

# Define the bounds for the optimization parameters

bounds = [(0, 90), (150, 210), (1.0, 1.5)]

# Define the initial guess for the optimization parameters

initial_guess = [lat, 180, 1.2]

# Perform the optimization

result = minimize(objective, initial_guess, args=(lat, lon, tz, PlantCapacityDC), bounds=bounds, method='L-BFGS-B')

# Extract the optimal parameters and the maximum AC output sum (negated minimized value)
optimal_params = result.x
max_annual_ac_cf = -result.fun # Negate the minimized value to get the maximum annual AC Capacity Factor

# Print the optimization results
print("Optimization Results:")
print(f"Optimal Surface Tilt: {optimal_params[0]:.2f} degrees")
print(f"Optimal Azimuth Angle: {optimal_params[1]:.2f} degrees")
print(f"Optimal DC/AC Ratio: {optimal_params[2]:.2f}")
print(f"Maximum Annual AC Capacity Factor: {max_annual_ac_cf*100:.2f}%")

from scipy.optimize import minimize
import pandas as pd

# Define the objective function to minimize (negative of the annual AC Capacity Factor)
def objective(params, lat, lon, tz, PlantCapacityDC):
    surface_tilt, azimuth_angle, dc_ac_ratio = params

    _, annual_ac_CF = pvsizing(lat, lon, tz, PlantCapacityDC, surface_tilt, azimuth_angle, dc_ac_ratio)

    return -annual_ac_CF

# Define the parameters for the optimization
lat = 33.4
lon = -112.1
tz = 'America/Phoenix'
PlantCapacityDC = 100

# Define the bounds for the optimization parameters

bounds = [(0, 90), (150, 210), (1.0, 1.5)]

# Define the initial guess for the optimization parameters

initial_guess = [lat, 180, 1.2]

# Perform the optimization

result = minimize(objective, initial_guess, args=(lat, lon, tz, PlantCapacityDC), bounds=bounds, method='L-BFGS-B')

# Extract the optimal parameters and the maximum AC output sum (negated minimized value)
optimal_params = result.x
max_annual_ac_cf = -result.fun # Negate the minimized value to get the maximum annual AC Capacity Factor

# Print the optimization results
print("Optimization Results:")
print(f"Optimal Surface Tilt: {optimal_params[0]:.2f} degrees")
print(f"Optimal Azimuth Angle: {optimal_params[1]:.2f} degrees")
print(f"Optimal DC/AC Ratio: {optimal_params[2]:.2f}")
print(f"Maximum Annual AC Capacity Factor: {max_annual_ac_cf*100:.2f}%")

"""# Problem 2 - Effect of Geographical Smoothing"""

# Blythe - 33.668 oN, 114.756 oW
# Las Vegas - 36.4489 oN , 114.7617 oW
# Reno - 40.7199 oN, 117.0628 oW
# Fresno - 36.5852 oN, 120.3792 oW

pvsizing(33.668,-114.756,'America/Los_Angeles',100, 33.668,180,1.2)

pvsizing(36.4489,-114.7617,'America/Los_Angeles',100, 36.4489,180,1.2)

pvsizing(40.7199,-117.0628,'America/Los_Angeles',100, 40.7199,180,1.2)

pvsizing(36.5852,-120.3792,'America/Los_Angeles',100, 36.5852,180,1.2)

"""# Problem 3 - CSP vs Solar PV Performance"""

# Ivanpah, CA (35.552 oN, 115.459 oW)
# Boston, MA (42.3555 oN, 71.0565 oW)

download_nsrdb_data(35.552,-115.459,'America/Los_Angeles')
download_nsrdb_data(42.3555,-71.0565,'America/New_York')

# Further Analysis carried out in Excel

"""# Problem 4 - Solar PV Efficiency"""

import pandas as pd
import numpy as np

A = 6 # cm2

phi1 = 1.8 * 10**17 # photons/ cm2/ s
phi2 = 1.0 * 10**17 # photons/ cm2/ s

QE1 = 0.9
QE2 = 0.7

Ts = 27 + 273.15 #K
J_0 = 1 * 10**-12 # A/cm2
k_B = 1.38 * 10**-23 # J/K

# 1. Compute the short-circuit current density Jsc (A/cm²) and short-circuit current Isc (A).

import numpy as np

q = 1.602 * 10**-19 # C

Jsc = q * ((QE1 * phi1) + (QE2 * phi2))
Isc = Jsc * A

# Compute Voc for the cell.

Voc = k_B * Ts/q * np.log(Jsc/J_0 + 1)

print(f"Short circuit current density: {Jsc*1000:.4f} mA/cm2")
print(f"Short circuit current: {Isc:.4f} A")
print(f"Opem circuit cell voltage: {Voc:.4f} V")

# Plot J-V Curve for the Solar PV Cell.

def J(V):
  J = Jsc - J_0 * np.exp(q * V/(k_B*Ts)-1)
  return J

def P(V):
  P = J(V) * V
  return P

from scipy.optimize import minimize
import pandas

# Define the objective function to minimize (negative of the power function)
def objective(V):
  J = Jsc - J_0 * np.exp(q * V/(k_B*Ts)-1)
  P = J * V
  return -P

# Define the bounds for the optimization parameters
bounds = [(0, Voc)]

# Define the initial guess for the optimization parameters
initial_guess = Voc / 2

# Perform the optimization
result = minimize(objective, initial_guess, bounds=bounds, method='L-BFGS-B')

Vmpp = result.x[0]
Pmax = -result.fun

print(f"Voltage at Maximum Power Point (Vmpp): {Vmpp:.4f} V")
print(f"Maximum Power (Pmax): {Pmax:.4f} W/cm²")

# Estimate the fill factor for the solar cell
FF = Pmax/ (Voc * Jsc)

# Calculate the efficiency at Input Power of 1000 W/m2 (STC)

Pin = 1000/(10**4) # W/cm^2

Efficiency = Pmax / Pin * 100

print(f"Fill Factor (FF): {FF:.4f}")
print(f"Efficiency: {Efficiency:.2f}%")

import matplotlib.pyplot as plt
import numpy as np

# Generate a range of V values from 0 to Voc
V_values = np.linspace(0, Voc, 100)

# Calculate the corresponding J values
J_values = J(V_values)

# Calculate the corresponding P values
P_values = P(V_values)

# Plot the J-V curve
fig, ax1 = plt.subplots(figsize=(4, 3))

ax1.plot(V_values, J_values, 'b-')
ax1.set_xlabel('Voltage (V)')
ax1.set_ylabel('Current Density (A/cm²)', color='b')
ax1.tick_params('y', colors='b')
ax1.grid(True)

# Add a second y-axis for power
ax2 = ax1.twinx()
ax2.plot(V_values, P_values, 'r-')
ax2.set_ylabel('Power (W/cm²)', color='r')
ax2.tick_params('y', colors='r')

plt.title('J-V and P-V Curves for the Solar PV Cell')
plt.show()